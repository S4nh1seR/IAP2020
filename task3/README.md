## Задание №3 по курсу "Анализ и обработка изображений".

Реализован алгоритм пирамидального построения карты порогов бинаризации. При уточнении порога используется среднее значение между минимальным и максимальным значением яркости из соответствующих карт минимумов и максимумов. (Среднее значение и среднее между средним и серединным значением работает хуже). Значение шумового порога выбрано равным 40.

## Запуск кода

### Стандартный режим
Binarizer PathToSrcImage PathToBinarized <BinarizationMode(avg/center/centerMinWeighted/avgCenterWeighted/byNoiseMap)(optional, default=center)> <NoiseLevel(optional, default=40)>

Параметры:
1. PathToSrcImage - путь к исходному изображению
2. PathToBinarized - путь к файлу-результату с бинаризованным изображением
3. BinarizationMode - "режим" бинаризации, отвечает за способ уточнения порога при повышения размерности карты (avg - среднее значение, center - серединное значение, centerMinWeighted - взвешенное среднее между минимумом и серединным значением с весами 2 и 1 соответственно, avgCenterWeighted - среднее между средним и серединой)
4. NoiseLevel - шумовой порог.

Для использования кода требуется библиотека OpenCV (для чтения/сохранения серых и цветных изображений), а также C-библиотека libtiff (для сохранения бинаризованных изображений в 1-depth формат без потерь).

### Режим с подсчетом зависимости уровня шума от яркости
Binarizer PathToSrcImage PathToBinarized <BinarizationMode(bySeparatedNoiseLevels)(obligatory parameter)> <SigmaMultiplier(float, optional, default=3.0)>

Здесь SigmaMultiplier - множитель, с которым будет подсчитан шумовой порог. (Относительно среднеквадратичного отклонения)

## Результаты работы и анализ ошибок

Результаты работы алгоритма на выданной выборке находятся в папке /results.

Алгоритм очень плохо справляется с шумным фоном, и на нем появляется рябь.

Здесь все упирается в выбранный шумовой порог - если его достаточно поднять, на одном их стартовых (самых нижних) уровней, где картинка сжата достаточно сильно, в сжатую ячейку попадает и фон, и текст, поэтому для фона сразу выбирается "правильный" шумовой порог, и далее он заливается белым. Но сильно поднимать шумовой порог тоже нельзя, поскольку на других изображениях мы грубо начинаем заливать участки, в действительности требующие уточнения порога. Проиллюстрируем проблему на примере.

Изображение IMG_0295 (картинка слева, по центру - бинаризованное с шумовым порогом 40 изображение, справа - бинаризованное с порогом 90 изображение)
![IMG_0295_badtn](./examples/IMG_0295_badtn.png)
И теперь контрпример к порогам, взятым в предыдущем примере - изображение 0025.
(слева - исходная картинка, по центру - с шумовым порогом 40, справа - с шумовым порогом 90)
![0025_badtn](./examples/0025_badtn.png)

Возможный способ побороться с проблемой - использовать вместо (min + max) / 2 при повышении размера карты другую статистику, например, взвешенное среднее между серединным значением и минимальным значением. (В предположении темного текста на светлом фоне, иначе вместо минимального по-хорошему нужно брать максимальное). Тем самым мы сильнее сужаем диапазон предполагаемого реального сигнала, все остальное считая шумом.

Пример - изображение 0025 (по центру - при апсэмплинге используется серединное значение,
справа - взвешенное среднее между серединным и минимальным, вес середины - 2, вес минимума - 1)
![0025_minmed](./examples/0025_minmed.png)
Однако в таком случае мы ожидаемо получаем побочный эффект - "сжатие текста" на бинаризованных картинках, буквы становятся слабее пропечатаны, во многих местах появляются дырки, поэтому данный способ нельзя считать нормальным решением. Результаты работы этого варианта лежат в директории results_minmed.

Был проведен ряд других экспериментов, но, к сожалению, так и не удалось найти универсальный способ, как побороть проблему.

Во-первых, пробовал построить зависимость дисперсии от уровня яркости (режим кода bySeparatedNoiseLevels: цветовой диапазон равномерно разбивается на 16 частей, далее скользящим окном радиуса 32 по всему изображению подсчитывается дисперсия. В каждой точке, в зависимости от среднего (уровня яркости) она заносится в общую сумму соответствующего цветового бина, в конце все дисперсии усредняются в каждом бине. В итоге для каждого диапазона яркости получаем значение сигмы - среднеквадратичного отклонения. Пользователем задается множитель сигмы, с помощью которого получается шумовой порог для каждого диапазона яркости. Сделать коэффициент одним и тем же для всех изображений не получается -- это приводит к очень плохим результатам на отдельных изображениях. При индивидуальной настройке параметра на некоторых изображениях становится лучше, на некоторых -- хуже, чем базовый вариант алгоритма. Таблица подобранных параметров множителя:

Image | SigmaMultiplier |
----- | --------------- |
0001 | 3.0 |
0025 | 5.0 |
0026 | 3.0 |
0027 | 4.0 |
IMG_0295 | 6.0 |
IMG_0531 | 2.5 |
IMG_0532 | 4.0 |
IMG_0533 | 3.0 |
IMG_0534 | 5.0 |
IMG_0535 | 3.0 |
IMG_0536 | 3.0 |
IMG_0538 | 2.0 |
IMG_0539 | 2.0 |
IMG_0540 | 3.0 |
IMG_1566 | 1.5 |

Результаты работы такого режима находятся в директории /results_with_sep_levels.

Проверено, что найденная зависимость коэф-в не обобщается более-менее простым способом по
самим величинам средних дисперсий.

Кроме этого, помимо пирамид минимумов, максимумов и средних, пробовал строить пирамиду дисперсий, тем самым получая индивидуальный шумовой порог в каждой точке на каждом шаге. Первоначальная карта дисперсий была оценена по исходному изображению с помощью скользящего окна небольшого радиуса. Карты дисперсий следующих уровней подсчитывались аналогично пирамиде средних - усреднением значений по 4-м ячейкам. Шумовой порог далее подбирался по следующей формуле max(a - c * sqrt(variance), b) (где a, b, c - постоянные константы) исходя из логики, что там где дисперсия больше, требуется лучшее уточнение порога, поэтому шумовой порог ниже. Добиться значимых улучшений таким способом не получилось.

## Время работы

Время работы алгоритма -- в среднем 70-80 msec на изображение.

В варианте в подсчетом зависимости дисперсии от яркости -- 300-350 msec на изображение.
